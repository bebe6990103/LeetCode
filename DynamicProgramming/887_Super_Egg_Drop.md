## 887. Super Egg Drop

- Hard
- 題目: 現有 k 顆相同的雞蛋和一棟有 n 層的建築，樓層從 1 到 n 編號。這棟建築存在一個「臨界樓層」f，滿足以下條件：如果你從高於 f 的樓層丟雞蛋，雞蛋會碎；如果從 f 樓或更低樓層丟下，雞蛋不會碎。你不知道 f 是多少，但可以透過丟雞蛋來測試。在每一次操作中，你可以從任意樓層丟下一顆「未破掉」的雞蛋。如果雞蛋碎了，它就不能再用；如果沒碎，還能繼續用於後續的測試。你的目標是設計一個策略，使你能在最少的測試次數內，保證找出 f 的確切數值，並回傳這個最少測試次數。

- Example
    - Input: k = 1, n = 2
    - Output: 2

- 思路
    - 以如果有 K 顆蛋、m 次丟蛋機會，最多可以保證查出哪一層樓範圍內的臨界樓層"的角度撰寫解法
    - dp的定義根據以下兩點事實
        - 1.無論在哪層樓丟雞蛋，雞蛋只可能摔破或沒破，破了的話就測樓下，否則就測樓上。
        - 2.無論上樓還是下樓，整體的樓層數=樓上的樓層數+樓下的樓層數+1(目前這層樓)

```cpp
class Solution {
public:
    int superEggDrop(int K, int N) {
        // dp[k][m] 表示 k 顆蛋、最多 m 次操作，可以測得的最大樓層數
        vector<vector<int>> dp(K + 1, vector<int>(N + 1, 0)); // 陣列多建到 N+1 只是方便，不代表 m 最多會到 N

        int m = 0;
        while (dp[K][m] < N) { // 主迴圈：不斷增加 m，直到覆蓋樓層 ≥ N (保證測出臨界樓層f)
            m++;
            for (int k = 1; k <= K; k++) {
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
            }
        }
        return m;
    }
};
```
